<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>juc三种辅助类</title>
    <link href="/2024/08/20/juc%E4%B8%89%E7%A7%8D%E8%BE%85%E5%8A%A9%E7%B1%BB/"/>
    <url>/2024/08/20/juc%E4%B8%89%E7%A7%8D%E8%BE%85%E5%8A%A9%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="juc三种辅助类-md"><a href="#juc三种辅助类-md" class="headerlink" title="juc三种辅助类.md"></a>juc三种辅助类.md</h1><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>计数器，适用于一次性事件同步，比如主线程等待多个子线程完成任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//10个运动员跑步，所有人准备好了，比赛开始</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">10</span> ; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;号同学准备中&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;号同学准备好了&quot;</span>);<br>                    countDownLatch.countDown();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br><br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;裁判正在等待所有人准备好&quot;</span>);<br>        countDownLatch.await();<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;所有人开始跑&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>号同学准备中<br><span class="hljs-number">1</span>号同学准备中<br><span class="hljs-number">2</span>号同学准备中<br><span class="hljs-number">4</span>号同学准备中<br><span class="hljs-number">5</span>号同学准备中<br><span class="hljs-number">6</span>号同学准备中<br><span class="hljs-number">7</span>号同学准备中<br><span class="hljs-number">8</span>号同学准备中<br><span class="hljs-number">9</span>号同学准备中<br>裁判正在等待所有人准备好<br><span class="hljs-number">10</span>号同学准备中<br><span class="hljs-number">1</span>号同学准备好了<br><span class="hljs-number">4</span>号同学准备好了<br><span class="hljs-number">8</span>号同学准备好了<br><span class="hljs-number">7</span>号同学准备好了<br><span class="hljs-number">5</span>号同学准备好了<br><span class="hljs-number">3</span>号同学准备好了<br><span class="hljs-number">10</span>号同学准备好了<br><span class="hljs-number">9</span>号同学准备好了<br><span class="hljs-number">6</span>号同学准备好了<br><span class="hljs-number">2</span>号同学准备好了<br>main所有人开始跑<br></code></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>循环栅栏，能够让多个线程在一个同步点等待， 直到所有线程都到达这个点再一起继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有好多个小朋友，他们要做的</span><br><span class="hljs-comment"> * 1.跑到起跑线</span><br><span class="hljs-comment"> * 2.准备好跑步</span><br><span class="hljs-comment"> * 3.开始跑步 </span><br><span class="hljs-comment"> * 我们要在所有小孩子2.准备好跑步 之后</span><br><span class="hljs-comment"> * 输出“所有小孩都准备好了” </span><br><span class="hljs-comment"> * 然后小孩们开始跑步</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//有5个小孩</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">people</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(people, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;所有小孩都准备好了&quot;</span>);<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= people; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;跑到起跑线&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;准备好跑步&quot;</span>);<br>                    barrier.await();<br>                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;开始跑步&quot;</span>);<br><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;,i+<span class="hljs-string">&quot;号小孩&quot;</span>).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2</span>号小孩跑到起跑线<br><span class="hljs-number">1</span>号小孩跑到起跑线<br><span class="hljs-number">3</span>号小孩跑到起跑线<br><span class="hljs-number">4</span>号小孩跑到起跑线<br><span class="hljs-number">5</span>号小孩跑到起跑线<br><span class="hljs-number">2</span>号小孩准备好跑步<br><span class="hljs-number">4</span>号小孩准备好跑步<br><span class="hljs-number">5</span>号小孩准备好跑步<br><span class="hljs-number">3</span>号小孩准备好跑步<br><span class="hljs-number">1</span>号小孩准备好跑步<br>所有小孩都准备好了<br><span class="hljs-number">1</span>号小孩开始跑步<br><span class="hljs-number">3</span>号小孩开始跑步<br><span class="hljs-number">5</span>号小孩开始跑步<br><span class="hljs-number">2</span>号小孩开始跑步<br><span class="hljs-number">4</span>号小孩开始跑步<br></code></pre></td></tr></table></figure><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>Semaphore作为多线程的许可证，线程进入 获取到许可证， 许可证分完了了，别人用不了 已分发许可证线程执行完任务，可以释放许可证，释放出来许可证，别的线程又能用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//6辆车，三个车位，车位的车走了，别的车才能用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;进入了停车场&quot;</span>);<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">6</span>));<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;------离开了了停车场&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;,i+<span class="hljs-string">&quot;号车&quot;</span>).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span>号车进入了停车场<br><span class="hljs-number">2</span>号车进入了停车场<br><span class="hljs-number">1</span>号车进入了停车场<br><span class="hljs-number">1</span>号车------离开了了停车场<br><span class="hljs-number">4</span>号车进入了停车场<br><span class="hljs-number">3</span>号车------离开了了停车场<br><span class="hljs-number">6</span>号车进入了停车场<br><span class="hljs-number">4</span>号车------离开了了停车场<br><span class="hljs-number">5</span>号车进入了停车场<br><span class="hljs-number">6</span>号车------离开了了停车场<br><span class="hljs-number">2</span>号车------离开了了停车场<br><span class="hljs-number">5</span>号车------离开了了停车场<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>juc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于jdk1.8的jvm总结</title>
    <link href="/2024/04/26/%E5%9F%BA%E4%BA%8Ejdk1.8%E7%9A%84jvm%E6%80%BB%E7%BB%93/"/>
    <url>/2024/04/26/%E5%9F%BA%E4%BA%8Ejdk1.8%E7%9A%84jvm%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="基于jdk1-8的jvm总结-md"><a href="#基于jdk1-8的jvm总结-md" class="headerlink" title="基于jdk1.8的jvm总结.md"></a>基于jdk1.8的jvm总结.md</h1><h2 id="什么是jvm"><a href="#什么是jvm" class="headerlink" title="什么是jvm"></a>什么是jvm</h2><ol><li>jvm是java程序运行时的虚拟机，java屏蔽了与操作系统相关的信息，只需要编译后的字节码，就能在任何平台运行，即<strong>一次编译，到处运行，</strong>简单理解就是，代码不变，编译后的class文件要在虚拟机中运行，不同的平台有不同的虚拟机制，后续适配的工作是jvm做的</li></ol><h2 id="jvm具体干了什么"><a href="#jvm具体干了什么" class="headerlink" title="jvm具体干了什么"></a>jvm具体干了什么</h2><ol><li>要回答这个问题，先要大致对jvm中代码运行的流程有一个了解：<ol><li>首先我们最开始学习java的时候，会在计算机中写一个<strong>hello world</strong>的例子；如下</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>这是一个我们能看懂的代码，要计算机能看懂就需要编译成class文件，命令就是</li></ol><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">javac TestDemo.java <br></code></pre></td></tr></table></figure><ol start="3"><li>这样，我们的同级目录就会多一个<strong>TestDemo.class</strong>文件，后续也是执行该文件</li><li>接下来就是jvm中的操作了，讲述操作前，先说一下jvm中有些什么</li></ol><h3 id="jvm模型"><a href="#jvm模型" class="headerlink" title="jvm模型"></a>jvm模型</h3><p><img src="/images/lJcOM1LYCb_IpRe_qQ3oSpHv0WHIu2ceBOFhALVGQR8.png" alt="image"><br>实际上，jvm的模型是很复杂的，这里只是画了比较重要的一些模块，挨个解释一下</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ol><li><strong>类加载器</strong>：字面意思，你写完的代码编译成字节码，然后需要jvm处理你的代码逻辑，在处理之前，需要加载你的类，具体加载的类是什么，先看下面demo</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TestDemo</span> <span class="hljs-variable">testDemo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestDemo</span>();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> testDemo.getClass().getClassLoader();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">stringClassLoader</span> <span class="hljs-operator">=</span> s.getClass().getClassLoader();<br>        System.out.println(<span class="hljs-string">&quot;classLoader的类加载器：&quot;</span>+classLoader);<br>        System.out.println(<span class="hljs-string">&quot;classLoader的类加载器的父类：&quot;</span>+classLoader.getParent());<br>        System.out.println(<span class="hljs-string">&quot;stringClassLoader的类加载器：&quot;</span>+stringClassLoader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">classLoader的类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2<br>classLoader的类加载器的父类：sun.misc.Launcher$ExtClassLoader@816f27d<br>stringClassLoader的类加载器：<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>第一个的结果是app～；第二个的结果是Ext～；第三个的结果是null，什么意思？String类不加载吗？</p><p>我们需要明白一个概念：<strong>有哪些类加载器？</strong></p><ul><li>引导类加载器（BootstrapClassloader）：用C++编写，是JVM自带的类加载器；负责加载Java的核心类库。（该加载器无法直接获取）</li><li>扩展类加载器（ExtClassloader）：负责加载&#x2F;jre&#x2F;lib&#x2F;ext目录下的jar包。</li><li>应用程序类加载器（AppClassloader）：负责加载java -classpath或-D java.class.path所指的目录下的类与jar包。（最常用的加载器）</li></ul><p>知道上面的概念，我们对号入座一下，平时自己写的类，如<strong>TestDemo</strong>的类加载器就是<strong>应用程序类加载器</strong>，所以是$AppClassLoader</p><p>他的父级（没有父子关系），就是拓展类加载器，具体位置如下图</p><p><img src="/images/56o2uQ_yIMRKA55ijQmur_Jo8ztgwi1-H6B3t8MXj0o.png" alt="image"></p><p>ps：想要看<strong>ext</strong>下面的类，就反编译<strong>ext</strong>路径下面的类测试一下，我随便找了一个，我们可以看看下面demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> TimeZoneNames_af.class.getClassLoader();<br>        System.out.println(classLoader);<br>    &#125;<br><br><span class="hljs-comment">//结果</span><br>sun.misc.Launcher$ExtClassLoader@53d8d10a<br></code></pre></td></tr></table></figure><p>引导类加载器（BootstrapClassloader）就更常见了，我们用的String，Object都是里面的类</p><p><strong>BootstrapClassloader为什么是null？</strong></p><p>网上大部分是说：BootstrapClassLoader 最顶层的加载类，主要加载核心类库。BootstrapClassLoader是由C&#x2F;C++编写的，它本身是虚拟机的一部分。 Object.class.getClassLoader()的返回值为null，因为Object类由Bootstrap ClassLoader加载，且Bootstrap ClassLoader不是一个java类，所以没有Bootstrap ClassLoader的java实例化对象，因此返回值为null。</p><p>这个我也不懂，因为没办法验证，但是我看了看源码，注释是这样的</p><p><img src="/images/YY385fnZYl4ucBsWfhSkkUbfor8lxMEwZ9t6UxHIrjA.png" alt="image"></p><p>所以，当你查询是null的时候，默认就是<strong>引导类加载器</strong>加载了这个类</p><ol><li><strong>双亲委派机制：</strong>双亲委派机制百度的解释是这样的【双亲委派机制（Parent Delegation Mechanism）是Java中的一种类加载机制。在Java中，类加载器负责加载类的字节码并创建对应的Class对象。双亲委派机制是指当一个类加载器收到类加载请求时，它会先将该请求委派给它的父类加载器去尝试加载。只有当父类加载器无法加载该类时，子类加载器才会尝试加载。】<ol><li><strong>说人话：</strong>就是你自己写了一个类，类加载器加载这个一个类的阶段，他会在拓展类和引导类中查找有没有一样的类（全路径+类名）有的话 就加载他们的 没有的话就加载你自己的，举个栗子</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> GYQ</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行这个main方法会报错，具体报错如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>否则 JavaFX 应用程序类必须扩展javafx.application.Application<br></code></pre></td></tr></table></figure><p>这个报错第一句话是String找不到main方法，但是上面的例子中String明显是有main方法的，为什么找不到？说明类加载器加载的类不是我们自己写的String类，那么他加载的只能是java原生的String类了，java原生的String中没有main方法，所以就报错了【找不到main方法】</p><p>这里我们总结一下双亲委派机制流程：</p><p>双亲委派机制的工作流程如下：</p><ul><li><strong>类加载请求</strong>：当应用程序请求加载一个类时（例如：调用<code>Class.forName(&quot;SomeClass&quot;)</code>），这个请求首先被传递给当前类加载器。</li><li><strong>向上委派</strong>：当前类加载器不会立即尝试加载这个类，而是将这个请求委派给其父类加载器。父类加载器继续向上委派，直到到达引导类加载器。</li><li><strong>类加载尝试</strong>：引导类加载器尝试加载这个类。如果引导类加载器找不到该类，就返回到子类加载器，子类加载器再继续尝试加载，依此类推。</li><li><strong>加载成功或失败</strong>：如果某个类加载器成功加载了这个类，那么加载过程结束；如果所有的类加载器都无法加载该类，最终会抛出<code>ClassNotFoundException</code>。</li></ul><h4 id="native，方法区"><a href="#native，方法区" class="headerlink" title="native，方法区"></a>native，方法区</h4><h5 id="native"><a href="#native" class="headerlink" title="native"></a>native</h5><ol><li>native关键字包装的方法，就是java语言到达不了的方法，需要调用底层c语言的方法，比如开启线程在cpu上，比如控制鼠标移动，键盘打字，在比如控制打印机打印东西等等，这些都是java语言干不了的事 ，所以封装类的时候，会加关键字<strong>native</strong>用来和底层的硬件交互</li><li><strong>线程开启</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;测试线程&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道start开启线程，点击进去这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//大致判断状态</span><br>        <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><span class="hljs-comment">//加个线程组</span><br>        group.add(<span class="hljs-built_in">this</span>);<br><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//关键是这一步  start0();</span><br>            start0();<br>            started = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!started) &#123;<br>                    group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//类中直接定义一个接口方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>start0()：</strong>正常情况，类中不能写接口的，但是有native关键字，他就默认调用底层c或者c++的方法，简单来说，Java无法在cpu上开线程，只能调别的更底层语言开放的接口去调用</p><p>再举一个栗子,操作鼠标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> AWTException &#123;<br>        <span class="hljs-type">Robot</span> <span class="hljs-variable">robot</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Robot</span>();<br>        robot.mouseMove(<span class="hljs-number">122</span>,<span class="hljs-number">222</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>mouseMove</strong>这个方法点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseMove</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>     peer.mouseMove(x, y);<br>     afterEvent();<br> &#125;<br></code></pre></td></tr></table></figure><p><strong>mouseMove</strong>这个方法点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseMove</span><span class="hljs-params">(<span class="hljs-type">int</span> var1, <span class="hljs-type">int</span> var2)</span> &#123;<br>    <span class="hljs-built_in">this</span>.mouseLastX = var1;<br>    <span class="hljs-built_in">this</span>.mouseLastY = var2;<br>    <span class="hljs-built_in">this</span>.mouseEvent(<span class="hljs-built_in">this</span>.fDevice.getCGDisplayID(), <span class="hljs-built_in">this</span>.mouseLastX, <span class="hljs-built_in">this</span>.mouseLastY, <span class="hljs-built_in">this</span>.mouseButtonsState, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mouseEvent</strong>这个方法点进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mouseEvent</span><span class="hljs-params">(<span class="hljs-type">int</span> var1, <span class="hljs-type">int</span> var2, <span class="hljs-type">int</span> var3, <span class="hljs-type">int</span> var4, <span class="hljs-type">boolean</span> var5, <span class="hljs-type">boolean</span> var6)</span>;<br></code></pre></td></tr></table></figure><p>底层控制鼠标也是用了别的语言的方法</p><p>这里就能提出一个新的概念<strong>JNI</strong></p><h5 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h5><p>JNI是Java Native Interface的缩写，通过使用 Java本地接口书写程序，可以确保代码在不同的平台上方便移植。从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互</p><p><img src="/images/HeeRR8bhpU2jo8g8uwioAj-cDVwQ0BWa-iws8uJTIFQ.png" alt="image"></p><p>通常情况下我们一般使用<code>jni</code>用来调用c或c++中的代码，下面的流程来描述了<code>native</code>方法的调用过程：</p><blockquote><p>Java Code -&gt; JNI -&gt; C&#x2F;C++ Code</p></blockquote><p>所以我们经常说java跨平台，但是我们下载jdk的时候，会区分什么：macos，linux，windows，64位，32位等，这就是jvm去调用本地方法，我们直接用java的方法，jvm会调用不同系统的底层的方法的实现</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><ol><li>jvm的方法区是类加载后存储<strong>类</strong>相关的信息<ol><li>方法区的主要内容<ol><li><strong>类信息</strong>：<ul><li>类的元数据（Metadata），包括类名、父类名、接口名、访问修饰符等。</li><li>类的结构信息，如字段、方法、构造函数等的描述。</li></ul></li><li><strong>常量池</strong>：<ul><li>字符串常量、数字常量等常量池信息。</li><li>方法和字段的符号引用。</li></ul></li><li><strong>方法字节码</strong>：<ul><li>已被加载的类的字节码，包括方法的字节码。</li></ul></li><li><strong>运行时常量池</strong>：<ul><li>每个类或接口对应的常量池，包含字面量和符号引用。</li></ul></li><li><strong>静态变量</strong>：<ul><li>类的静态变量，这些变量在类加载时分配并初始化。</li></ul></li><li><strong>即时编译器编译后的代码</strong>：<ul><li>如果使用了即时编译器（JIT），方法区还可能存储编译后的本地代码。</li></ul></li></ol></li><li>方法区的作用<ol><li><strong>类加载和解析</strong>：<ul><li>当类加载器加载一个类时，类的元数据会被存储在方法区。</li></ul></li><li><strong>字节码执行</strong>：</li></ol><ul><li>方法的字节码存储在方法区中，JVM 在执行方法时会读取这些字节码。</li></ul><ol start="3"><li><strong>常量池的维护</strong>：</li></ol><ul><li>方法区包含运行时常量池，用于存储类文件常量池中的符号引用，这些引用在类加载和运行时会被解析为具体的内存地址。</li></ul><ol start="4"><li><strong>静态变量管理</strong>：</li></ol><ul><li>方法区存储类的静态变量，这些变量在类的生命周期内都存在。</li></ul></li><li>方法区与堆、栈的区别<ol><li><strong>方法区</strong>：<ul><li>存储类的结构信息、方法的字节码、静态变量等。</li><li>用于存储类元数据和方法字节码。</li></ul></li><li><strong>堆（Heap）</strong>：<ul><li>存储对象实例。</li><li>主要用于存储运行时的对象，包括实例变量和数组。</li></ul></li><li><strong>栈（Stack）</strong>：<ul><li>存储每个线程的栈帧，包含局部变量、操作数栈和方法返回地址等。</li><li>每个方法调用都会创建一个栈帧，栈帧中包含该方法执行时所需的信息。</li></ul></li></ol></li></ol></li></ol><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ol><li>首先回顾知识点，小学二年级的时候我们就教过<strong>栈</strong>是一种先进后出的数据结构，可以把<strong>栈</strong>理解成一个开了盖的瓶子，最先丢进去的东西，最后才能掏出来</li><li>jvm中的栈做了什么？<ol><li>还是先看百度：Java 虚拟机栈(Java Virtual Machine Stacks)，早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。</li><li>讲的比较抽象，但是有一句关键：<strong>每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用</strong></li><li>简单理解就是一个栈的数据结构，在调用java代码的方法时候，把一个个方法按前后顺序放到栈中，调用完了，再一个个弹出去</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Demo1.a();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>上面的代码，最开始调用了一个main方法，然后main中调用了a方法，栈中结构如下</li></ol><p><img src="/images/XYW26ax5TMs4UG2rN3XsMTs8b9U5FM7VUlh2KfRw05s.png" alt="image"></p><ol start="5"><li>栈的基本结构知道了，那说一个我们写代码偶尔会犯的错</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Demo1.a();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        b();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>        a();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行这个方法会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at com.gyq.callable.Demo1.b(Demo1.java:<span class="hljs-number">21</span>)<br>at com.gyq.callable.Demo1.a(Demo1.java:<span class="hljs-number">17</span>)<br>at com.gyq.callable.Demo1.b(Demo1.java:<span class="hljs-number">21</span>)<br>at com.gyq.callable.Demo1.a(Demo1.java:<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>这个栈溢出的问题是怎么来的？</p><ul><li>栈中最先进去main方法</li><li>然后main中调用a方法，栈中压入a方法</li><li>a调用b方法，栈中压入b方法</li><li>b再调用a方法，栈中再压入a方法</li><li>死循环压入a、b方法 栈的空间爆了，就会爆<strong>StackOverflowError</strong></li></ul><p><img src="/images/JFNRs9T7aBY1kBmM8d8V1IuoWaUvgGLR_KFLZUJqwOo.png" alt="image"></p><ol start="6"><li>实际上，栈的真实结构还是要更复杂一点的，栈的每一节都是由<strong>栈帧</strong>构成的，<strong>栈帧</strong>是什么样的呢？栈帧里面包含子栈，父栈，局部变量，操作数栈<ol><li>父栈就是初始方法栈，比如main方法中调用add方法，父栈存main；子栈是被调用方法，子栈存add</li><li>局部变量就是该方法中所有定义的对象</li><li>操作数栈是 Java 虚拟机（JVM）执行方法调用时用于记录操作数和方法返回值的栈结构</li></ol></li></ol><p><img src="/images/test1234565432.png" alt="image"></p><pre><code class="hljs">  1. 举个栗子：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a * b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> add(multiply(x, y), z);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calculator</span> <span class="hljs-variable">calculator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Calculator</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalResult</span> <span class="hljs-operator">=</span> calculator.compute();<br>        System.out.println(finalResult);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们来分析一下栈结构中怎么存储这段代码</p><p>在这个例子中，我们有三个方法：<code>multiply</code>、<code>add</code> 和 <code>compute</code>。<code>compute</code> 方法调用了 <code>multiply</code> 和 <code>add</code>，然后返回最终结果。</p><h5 id="栈的详细使用过程"><a href="#栈的详细使用过程" class="headerlink" title="栈的详细使用过程"></a>栈的详细使用过程</h5><ul><li><code>main</code> 方法<ul><li>调用 <code>compute</code> 方法，创建一个 <code>Calculator</code> 实例，并调用其 <code>compute</code> 方法。</li></ul></li><li><code>compute</code> 方法<ul><li>初始化局部变量 <code>x=2</code>、<code>y=3</code>、<code>z=4</code>。</li><li>将 <code>x=2</code> 和 <code>y=3</code> 推入操作数栈，并调用 <code>multiply</code> 方法。</li></ul></li></ul><ol><li>调用 <code>multiply</code> 方法<ol><li>创建新的栈帧，并将 <code>x=2</code> 和 <code>y=3</code> 作为参数传递。</li><li>在操作数栈中进行 <code>2 * 3</code> 计算，结果为 <code>6</code>。</li><li>将结果 <code>6</code> 推入调用者（<code>compute</code> 方法）的操作数栈。</li></ol></li><li>回到 <code>compute</code> 方法<ol><li>将 <code>6</code> 和 <code>z=4</code> 推入操作数栈，并调用 <code>add</code> 方法。</li></ol></li><li>调用 <code>add</code> 方法<ol><li>创建新的栈帧，并将 <code>6</code> 和 <code>z=4</code> 作为参数传递。</li><li>在操作数栈中进行 <code>6 + 4</code> 计算，结果为 <code>10</code>。</li><li>将结果 <code>10</code> 推入调用者（<code>compute</code> 方法）的操作数栈。</li></ol></li><li>回到 <code>compute</code> 方法<ol><li>将结果 <code>10</code> 赋值给局部变量 <code>result</code>。</li><li>返回 <code>result</code>，即 <code>10</code>，推入调用者（<code>main</code> 方法）的操作数栈。</li></ol></li></ol><ul><li><code>main</code> 方法<ul><li>将 <code>finalResult=10</code> 输出到控制台。</li></ul></li></ul><h5 id="栈帧示意图"><a href="#栈帧示意图" class="headerlink" title="栈帧示意图"></a>栈帧示意图</h5><p>以下是调用过程中各个栈帧和操作数栈的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> main 方法调用 compute 方法：<br>main 方法栈帧：<br>+-------------------+<br>| 局部变量表:         |<br>| calculator        |<br>| finalResult       |<br>+-------------------+<br>| 操作数栈:           |<br>|                   |<br>+-------------------+<br><br><span class="hljs-number">2.</span> compute 方法初始化局部变量 x, y, z：<br>compute 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| x = <span class="hljs-number">2</span>             |<br>| y = <span class="hljs-number">3</span>             |<br>| z = <span class="hljs-number">4</span>             |<br>| result            |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><span class="hljs-number">3.</span> 调用 multiply 方法：<br>compute 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| x = <span class="hljs-number">2</span>             |<br>| y = <span class="hljs-number">3</span>             |<br>| z = <span class="hljs-number">4</span>             |<br>| result            |<br>+-------------------+<br>| 操作数栈:         |<br>| <span class="hljs-number">2</span>                 |<br>| <span class="hljs-number">3</span>                 |<br>+-------------------+<br><br>multiply 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| a = <span class="hljs-number">2</span>             |<br>| b = <span class="hljs-number">3</span>             |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><span class="hljs-number">4.</span> multiply 方法返回 <span class="hljs-number">6</span>：<br>compute 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| x = <span class="hljs-number">2</span>             |<br>| y = <span class="hljs-number">3</span>             |<br>| z = <span class="hljs-number">4</span>             |<br>| result            |<br>+-------------------+<br>| 操作数栈:         |<br>| <span class="hljs-number">6</span>                 |<br>+-------------------+<br><br><span class="hljs-number">5.</span> 调用 add 方法：<br>compute 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| x = <span class="hljs-number">2</span>             |<br>| y = <span class="hljs-number">3</span>             |<br>| z = <span class="hljs-number">4</span>             |<br>| result            |<br>+-------------------+<br>| 操作数栈:         |<br>| <span class="hljs-number">6</span>                 |<br>| <span class="hljs-number">4</span>                 |<br>+-------------------+<br><br>add 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| a = <span class="hljs-number">6</span>             |<br>| b = <span class="hljs-number">4</span>             |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><span class="hljs-number">6.</span> add 方法返回 <span class="hljs-number">10</span>：<br>compute 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| x = <span class="hljs-number">2</span>             |<br>| y = <span class="hljs-number">3</span>             |<br>| z = <span class="hljs-number">4</span>             |<br>| result = <span class="hljs-number">10</span>       |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><span class="hljs-number">7.</span> compute 方法返回 <span class="hljs-number">10</span>：<br>main 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| calculator        |<br>| finalResult = <span class="hljs-number">10</span>  |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><span class="hljs-number">8.</span> main 方法输出结果 <span class="hljs-number">10</span> 到控制台：<br>main 方法栈帧：<br>+-------------------+<br>| 局部变量表:       |<br>| calculator        |<br>| finalResult = <span class="hljs-number">10</span>  |<br>+-------------------+<br>| 操作数栈:         |<br>+-------------------+<br><br><br></code></pre></td></tr></table></figure><p><strong>总结</strong>：知道了栈的基本概念，就能得出一些简单的理解，</p><ol><li>首先，栈是不会进行垃圾回收机制的，如果栈中的一节被回收了，子帧，父帧就连不上，这个代码就崩了</li><li>栈里面是不会爆OOM的，最多可能爆一个<strong>StackOverflowError</strong>，那么，我们经常说的<strong>GC，OOM，jvm调优</strong>这些究竟是什么？主要讲的是<strong>堆</strong>中出现的问题</li></ol><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>写到这里，我们大概要有一点jvm逻辑框架，我们写一个java的类，编译成class文件，然后jvm中类加载器预处理，加载完正确的类，然后方法区初始化类，把类和类的方法等加载了，然后走本地方法的就JNI调用本地方法，正常的java方法，就把编译好的字节码一行一行的读，读到一个方法，就给栈中压一个方法。。。那么，堆在其中起到了什么作用呢？我们慢慢分析</p><p>首先分析一下堆中存储了什么 我们结合代码分析一下</p><h5 id="综合理解"><a href="#综合理解" class="headerlink" title="综合理解"></a>综合理解</h5><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryDemo</span> &#123;<br>    <span class="hljs-comment">// 静态变量，存储在方法区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 实例变量，存储在堆中</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> instanceCounter;<br><br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MemoryDemo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.instanceCounter = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化实例变量</span><br>    &#125;<br><br>    <span class="hljs-comment">// 静态方法，存储在方法区</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// main方法的局部变量，存储在栈中</span><br>        <span class="hljs-type">MemoryDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MemoryDemo</span>();<br>        demo.incrementCounters();<br>    &#125;<br><br>    <span class="hljs-comment">// 实例方法，存储在方法区</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCounters</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 局部变量，存储在栈中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">localCounter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 增加局部变量</span><br>        localCounter++;<br>        <br>        <span class="hljs-comment">// 增加实例变量</span><br>        <span class="hljs-built_in">this</span>.instanceCounter++;<br>        <br>        <span class="hljs-comment">// 增加静态变量</span><br>        MemoryDemo.staticCounter++;<br><br>        <span class="hljs-comment">// 打印结果</span><br>        System.out.println(<span class="hljs-string">&quot;Local Counter: &quot;</span> + localCounter);<br>        System.out.println(<span class="hljs-string">&quot;Instance Counter: &quot;</span> + <span class="hljs-built_in">this</span>.instanceCounter);<br>        System.out.println(<span class="hljs-string">&quot;Static Counter: &quot;</span> + MemoryDemo.staticCounter);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h6><ol><li><strong>方法区</strong><ul><li><code>MemoryDemo</code>类的字节码和结构信息存储在方法区。</li><li>静态变量<code>staticCounter</code>和静态方法<code>main</code>、实例方法<code>incrementCounters</code>也存储在方法区。</li></ul></li><li><strong>栈</strong></li></ol><ul><li>当<code>main</code>方法开始执行时，<code>main</code>方法的帧被压入栈中。</li><li><code>main</code>方法中的局部变量<code>demo</code>被存储在栈中。</li><li><code>incrementCounters</code>方法调用时，其局部变量<code>localCounter</code>也被存储在栈中。</li><li>方法执行结束后，这些局部变量和方法帧从栈中弹出。</li></ul><ol start="3"><li><strong>堆</strong></li></ol><ul><li>当通过<code>new MemoryDemo()</code>创建<code>demo</code>对象时，<code>MemoryDemo</code>对象被分配在堆中。</li><li><code>demo</code>对象的实例变量<code>instanceCounter</code>存储在堆中，并在对象创建时初始化。</li></ul><h6 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h6><ol><li><strong>类加载</strong><ul><li><code>MemoryDemo</code>类加载后，其字节码和静态变量<code>staticCounter</code>存储在方法区。</li></ul></li><li><strong>方法调用</strong></li></ol><ul><li><code>main</code>方法被调用，<code>main</code>方法帧被压入栈中，局部变量<code>demo</code>存储在栈中。</li></ul><ol start="3"><li><strong>对象创建</strong></li></ol><ul><li><code>new MemoryDemo()</code>调用构造方法，创建<code>MemoryDemo</code>对象，分配在堆中，实例变量<code>instanceCounter</code>初始化为0。</li></ul><ol start="4"><li><strong>方法调用与局部变量</strong></li></ol><ul><li><code>incrementCounters</code>方法被调用，方法帧压入栈中，局部变量<code>localCounter</code>在栈中初始化为0。</li><li><code>localCounter</code>、<code>this.instanceCounter</code>、<code>MemoryDemo.staticCounter</code>分别递增。</li></ul><ol start="5"><li><strong>打印结果</strong></li></ol><ul><li><code>incrementCounters</code>方法结束，方法帧和局部变量从栈中弹出。</li></ul><hr><p>由上面可见 堆中存储的是：</p><ul><li>堆是JVM中用于存储对象和数组的区域。所有通过<code>new</code>关键字创建的对象和数组都在堆中分配内存。堆是JVM内存模型中最大的一部分，主要用于存储程序运行时动态生成的数据。</li><li>即 方法中new的对象，以及对象中有定义的变量（不是静态变量，静态变量要进入方法区）</li></ul><h5 id="一个常见的堆的问题"><a href="#一个常见的堆的问题" class="headerlink" title="一个常见的堆的问题"></a>一个常见的堆的问题</h5><p>我们经常听过一个问题<strong>OOM</strong>，这是个什么东西，OOM，全称：<strong>OutOfMemoryError****，</strong>我们理解一下，内存溢出，什么溢出，总不可能是栈溢出，因为栈溢出之前已经理解了，栈中东西对太多直接会爆<strong>StackOverflowError</strong>，OOM是把内存撑爆了，那就只有堆能创造这个报错，那么我们就可以人为模拟一下这个错误，刚才讲过，方法中的<strong>基本变量</strong>是存到<strong>栈</strong>的<strong>局部变量表</strong>中的，要给堆中塞东西，就要用到<strong>引用变量</strong>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            str.append(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">99999999</span>));<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><br><span class="hljs-comment">//结果</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3332</span>)<br>at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="hljs-number">124</span>)<br>at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="hljs-number">674</span>)<br>at java.lang.StringBuilder.append(StringBuilder.java:<span class="hljs-number">214</span>)<br>at com.gyq.openAi.Test.main(Test.java:<span class="hljs-number">19</span>)<br></code></pre></td></tr></table></figure><p>调用这个方法，最好将默认堆内存和最大堆内存设置的小一点，要不然复现时间长</p><p><img src="/images/T80QLyF-QceyjlmNsENc-FMxcUaiP1OFMYB_wLPVAmg.png" alt="image"></p><h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><ol><li>堆中区分区块<ol><li>刚才我们了解了堆中存放的对象是什么，现在我们了解一下堆中内存的分区</li></ol></li></ol><h6 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h6><p><img src="/images/t6wLgwaN7ZxcjO7IPw0La7WB0LP7bmvu5ni-XkRrRCE.png" alt="image"></p><ul><li>优点：不需要额外的空间。</li><li>缺点：两次扫描，严重浪费时间，会产生内存碎片。</li></ul><h6 id="标记清除压缩法"><a href="#标记清除压缩法" class="headerlink" title="标记清除压缩法"></a>标记清除压缩法</h6><p><img src="/images/rbIJWuviMkLJ_llqsCRXqnFq5OsjdI41eAK-88IgGCw.png" alt="image"></p><h6 id="标记清除压缩（改进）"><a href="#标记清除压缩（改进）" class="headerlink" title="标记清除压缩（改进）"></a>标记清除压缩（改进）</h6><p>可以进行多次标记清除后，再进行一次压缩。</p><h6 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h6><p><img src="/images/ilFdZ2sgNJNfMTZlENxby8VX-lVPuHspNw8qAPPHb9M.png" alt="image"></p><p><img src="/images/6aaoBDJ88ImUtUL0eI8TcpawaoKqAGiSRHUfeis42MA.png" alt="image"></p><ul><li>好处：没有内存的碎片。</li><li>坏处：浪费了内存空间（多了一半空间to永远是空）。假设对象100%存活（极端情况），不适合使用复制算法。</li></ul><p><strong>使用场景</strong></p><p>复制算法最佳使用场景：对象存活度较低的时候（新生区）</p><h6 id="GC算法总结"><a href="#GC算法总结" class="headerlink" title="GC算法总结"></a>GC算法总结</h6><ul><li>时间复杂度：复制算法&gt;标记清除算法&gt;标记压缩算法</li><li>内存整齐度：复制算法&#x3D;标记压缩算法&gt;标记清除算法</li><li>内存利用率：标记压缩算法&#x3D;标记清除算法&gt;复制算法</li></ul><p>思考一个问题：难道没有最优算法吗？</p><p>答案：没有，没有最好的算法，只有最合适的算法—&gt;GC：分代收集算法</p><p>年轻代：</p><ul><li>存活率低</li><li>复制算法</li></ul><p>老年代：</p><ul><li>区域大：存活率高</li><li>标记清除（内存碎片不是太多）+标记压缩混合实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>jvm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jvm</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
